
// https://www.arduino.cc/reference/en/
#include <Arduino.h>

#include "angleAndPosition.h"
#include "binary.h"
#include "bluetoothLowEnergy.h"
#include "brick.h"
#include "bumper.h"
#include "drive.h"
#include "errorIndicator.h"
#include "history.h"
#include "infrared.h"
#include "map.h"
#include "motionTracker.h"
#include "motor.h"
#include "navigator.h"
#include "pixels.h"
#include "schedule.h"
#include "systemInfo.h"
#include "ultrasonic.h"

ErrorIndicator errorIndicator(LED_BUILTIN, SERIAL_BAUD_RATE);

Motor leftMotor(LEFT_MOTOR_DIRECTION_PIN, LEFT_MOTOR_SPEED_PIN,
                LEFT_MOTOR_ENCODER_A_PIN, LEFT_MOTOR_ENCODER_B_PIN,
                LEFT_MOTOR_ROTATION_INVERTED);

Motor rightMotor(RIGHT_MOTOR_DIRECTION_PIN, RIGHT_MOTOR_SPEED_PIN,
                 RIGHT_MOTOR_ENCODER_A_PIN, RIGHT_MOTOR_ENCODER_B_PIN,
                 RIGHT_MOTOR_ROTATION_INVERTED);

Drive drive(&leftMotor, &rightMotor, DEFAULT_DRIVE_SPEED);

Pixels pixels(PIXELS_DATA_PIN, LED_COUNT, LED_ROTATION_OFFSET);
Ultrasonic ultrasonic(ULTRASONIC_TRIGGER, ULTRASONIC_ECHO,
                      ULTRASONIC_TIMEOUT_MICROSECONDS, ULTRASONIC_MAX_DISTANCE,
                      ULTRASONIC_DATA_SHELF_LIFE,
                      FRONT_ULTRASONIC_FORWARD_DISTANCE);

Infrared leftInfrared(&errorIndicator, LEFT_INFRARED_INDEX,
                      LEFT_INFRARED_FORWARD_DISTANCE);
Infrared rightInfrared(&errorIndicator, RIGHT_INFRARED_INDEX,
                       RIGHT_INFRARED_FORWARD_DISTANCE);
Infrared frontLeftInfrared(&errorIndicator, FRONT_LEFT_INFRARED_INDEX,
                           FRONT_LEFT_INFRARED_FORWARD_DISTANCE);
Infrared frontRightInfrared(&errorIndicator, FRONT_RIGHT_INFRARED_INDEX,
                            FRONT_RIGHT_INFRARED_FORWARD_DISTANCE);

Bumper bumper(BUMPER_SHIFT_REG_DATA, BUMPER_SHIFT_REG_LOAD,
              BUMPER_SHIFT_REG_CLOCK, BUMPER_INTERRUPT_PIN,
              BUMPER_ROTATION_OFFSET);

BluetoothLowEnergy bluetoothLowEnergy(MAIN_SERVICE_UUID, ROBOT_POSE_UUID,
                                      BRICK_UUID);

MotionTracker motionTracker(&leftMotor, &rightMotor, INITIAL_ANGLE);

Navigator navigator(&motionTracker, &drive);

BrickList brickList;

Map gridMap;

// ███████ ████████  █████  ██████  ████████     ██   ██ ███████ ██████  ███████
// ██         ██    ██   ██ ██   ██    ██        ██   ██ ██      ██   ██ ██
// ███████    ██    ███████ ██████     ██        ███████ █████   ██████  █████
//      ██    ██    ██   ██ ██   ██    ██        ██   ██ ██      ██   ██ ██
// ███████    ██    ██   ██ ██   ██    ██        ██   ██ ███████ ██   ██ ███████
// https://patorjk.com/software/taag/

/*
Im going to preface all of this by saying that I ran out of time,
There is still a lot of documenting and refactoring that I would like to do, but
in its current state the logic is sound and everything works.


Logic Flow

 Oversimplification
  Stage 1 - Follow the left wall, plot all the bricks encountered om this lap.
  Stage 2 - Use the flood fill to make a first attempt at plotting the maze.
  Stage 3 - Use this map to drive through the centre of the maze.
  Stage 4 - Hit an island in the middle of the maze, then left wall follow all
            the way around this island Stage 4 - hit an island in the middle of
            the maze.
  Stage 5 - Drive back to the start of the maze.
  Stage 6 - Use the flood fill Solve and drive the maze.
  Stage 7 - Celebrate.


The robot starts by facing away from the maze, with its coordinates off the
maze, It then drives until it finds a wall It uses that wall to calibrate its
 y position to place itself on the map. It then turns right and does the same
again to calibrate its x Position.


Ive implemented a naming convention for tagging variables
//   _G = global
//   _L = local version of a global or pointer
//   _C = constant
//   _P = pointer
//   _S = state
//   _I = index



There are two important structs that are similar in this code,
Position and MapPoint, both store x and y, but Position is measured in
millimeters and MapPoint is in centimeter, MapPoint is also stores its values as
ints, because its primary use is referencing items in the map via its index.


Default units;

time - miliseconds
distance - millimeter
angle - degrees


It is true that not everything is fully documented, but everything is
modularized and made robust.

Thought my robustness ive been able to;
. Pretty much remove all false positives from the IR reading.
. Detaching the ultrasonic from the timer and get US reading and BLE working
  simultaneously.
. Put everything on a single thread.
. Achieve mm precise Odometry, this robot could lap the maze 10 times and still
  know exactly where it is.

None of the code submitted was generated by AI.
*/

void setup() {
    Serial.begin(SERIAL_BAUD_RATE);

    errorIndicator.assignPixels(&pixels);
    errorIndicator.assignDrive(&drive);
    errorIndicator.setup();

    // Interrupts must be connected to a void function pointer, not class
    // methods, so to attach a class method to an interrupt pin it must be
    // converted to a void function pointer using a global instance and a lamda
    // function.
    leftMotor.setup([]() { leftMotor.isr(); });
    rightMotor.setup([]() { rightMotor.isr(); });

    pixels.setup();

    leftInfrared.setup();
    rightInfrared.setup();
    frontLeftInfrared.setup();
    frontRightInfrared.setup();

    ultrasonic.setup([]() { ultrasonic.isr(); });

    bumper.setup([]() { bumper.isr(); });

    bluetoothLowEnergy.setup(BLE_DEVICE_NAME, BLE_MAC_ADDRESS, &errorIndicator);
}

void polls() {
    frontLeftInfrared.poll();
    frontRightInfrared.poll();
    leftInfrared.poll();
    rightInfrared.poll();

    ultrasonic.poll();

    motionTracker.poll();

    bluetoothLowEnergy.poll();
}

// Forward declaration of states.
void followingLeftWall_S();
void aligningWithWall_S();
void UseMazeToGoTo(Position);
void followingMaze_S();
void celebrating_S();

voidFuncPtr nextState_GP = followingLeftWall_S;

enum Objective {
    NoObjective,
    MapOuterWall,
    DriveToEndViaCentre,
    MapIsland,
    DriveToStart,
    DriveToEnd,
    CompletedMaze,

};

Objective currentObjective_G = MapOuterWall;

void sendDataOverBLE() {
    bluetoothLowEnergy.sendRobotPose(motionTracker.getPose());
    bluetoothLowEnergy.sendBrickList(brickList);
}

void followingLeftWall_S() {
    Pose robotPose = motionTracker.getPose();
    Position robotPosition = motionTracker.getPosition();
    Angle robotAngle = motionTracker.getAngle();

    static Objective lastObjective = NoObjective;
    bool objectiveIsNew = lastObjective != currentObjective_G;
    lastObjective = currentObjective_G;

    // static position for the stats and end position of lines seen by the left
    // and right sensors.
    static Position leftStatingCorner;
    static Position leftEndingCorner;
    static Position rightStatingCorner;
    static Position rightEndingCorner;

    // The typical distance the robot has moved before it noticed a corner has
    // appeared.
    const int startingCornerDropOff = 40;

    // If the current objective it to map the outer wall, check if enough laps
    // of the map have been done, and if so move onto the next objective
    if (currentObjective_G == MapOuterWall) {
        static Position otherSideOfMaze;
        static int halfLaps;
        if (objectiveIsNew) {
            otherSideOfMaze = {1300, 1800};
            halfLaps = 0;
        }
        const int otherSideTolerance = 200;

        int distanceToOtherSide = robotPosition.distanceTo(otherSideOfMaze);

        if (distanceToOtherSide < otherSideTolerance) {
            halfLaps += 1;
            bool halfLapsIsOdd = halfLaps & 1;

            if (halfLapsIsOdd) {
                otherSideOfMaze = {200, 200};
            } else {
                otherSideOfMaze = {1300, 1800};
            }

            if (halfLaps == 2) {
                currentObjective_G = DriveToEndViaCentre;
                UseMazeToGoTo({1300, 1800});
            }
        }
    }

    // If the current objective it to map the inner island, check if the robot
    // have reached its starting point, and if so move onto the next objective.
    if (currentObjective_G == MapIsland) {
        // A flag that for checking if the robot has driven far enough from its
        // starting position.
        static bool innerTraveledFarEnough;
        static Position islandStartPosition;

        if (objectiveIsNew) {
            islandStartPosition = robotPosition;
            innerTraveledFarEnough = false;
        }

        const int islandOuterTolerance = 150;

        const int islandInnerTolerance = 75;

        int distanceFromStart = robotPosition.distanceTo(islandStartPosition);

        // If driven far enough from the start position, raise a flag.
        if (distanceFromStart > islandOuterTolerance) {
            innerTraveledFarEnough = true;
        }

        // If close enough to the start, and the outer flag has been raised,
        // move onto the next state.
        if ((distanceFromStart < islandInnerTolerance) &&
            innerTraveledFarEnough) {
            currentObjective_G = DriveToStart;
            UseMazeToGoTo({200, 200});
            return;
        }
    }

    int orthogonalOffset = robotAngle.OrthogonalOffset();
    drive.forwards(orthogonalOffset);

    int frontUSDistance = ultrasonic.readFromRobotCenter();

    const int orthTolerance = 5;

    if (robotAngle.isOrthogonal(orthTolerance)) {
        Angle roundedRobotAngle = robotAngle.closestRightAngle();

        static PassiveSchedule compareBrickScheduler(10);

        if (compareBrickScheduler.isReadyToRun()) {
            int leftIRDistance = leftInfrared.readFromRobotCenter();

            // If not using front sensor, it will be using the left sensor.
            static bool usingFrontSensor = false;

            // Alternate between the front and the left sensor.
            usingFrontSensor = !usingFrontSensor;

            if ((usingFrontSensor) && (frontUSDistance > 120)) {
                Angle frontSensorAngle = roundedRobotAngle;
                brickList.handleBrickFromSensorAndMap(
                    robotPosition, frontSensorAngle, frontUSDistance,
                    orthTolerance, &gridMap);
            }

            else if ((!usingFrontSensor) && (leftIRDistance > 120)) {
                Angle leftSensorAngle = roundedRobotAngle + 90;
                brickList.handleBrickFromSensorAndMap(
                    robotPosition, leftSensorAngle, leftIRDistance,
                    orthTolerance, &gridMap);
            }
        }
    }

    if (leftInfrared.brickAppeared(150, 50)) {
        float distanceToWall = leftInfrared.readFromRobotCenter(false);

        leftStatingCorner = Position(-distanceToWall, -startingCornerDropOff);
        leftStatingCorner.transformByPose(robotPose);

        brickList.handleBrickFromWallPosition(leftStatingCorner);
    };

    if (leftInfrared.brickDisappeared(150, 50)) {
        float distanceToWall = leftInfrared.readFromRobotCenter(true);

        leftEndingCorner = Position(-distanceToWall, 0);
        leftEndingCorner.transformByPose(robotPose);

        brickList.handleBrickFromLine(robotPosition, leftStatingCorner,
                                      leftEndingCorner);

        drive.stop();
        sendDataOverBLE();

        // Drive 150 mm then turn left
        navigator.turnLeft(150);
    }

    if (rightInfrared.brickAppeared(150, 50)) {
        float distanceToWall = rightInfrared.readFromRobotCenter(false);
        rightStatingCorner = Position(distanceToWall, 0);
        rightStatingCorner.transformByPose(robotPose);
    }

    if (rightInfrared.brickDisappeared(150, 50)) {
        float distanceToWall = rightInfrared.readFromRobotCenter(true);

        rightEndingCorner = Position(distanceToWall, -startingCornerDropOff);
        rightEndingCorner.transformByPose(robotPose);

        brickList.handleBrickFromLine(robotPosition, rightStatingCorner,
                                      rightEndingCorner);
    }

    // if a wall is there
    if (frontUSDistance < 185 && frontUSDistance != -1) {
        nextState_GP = aligningWithWall_S;

        drive.stop();
        sendDataOverBLE();
    }
}

void aligningWithWall_S() {
    int FLDist = frontLeftInfrared.readSafe();
    int FRDist = frontRightInfrared.readSafe();

    bool cantSeeLeft = (FLDist <= -1 || FLDist > 200);
    bool cantSeeRight = (FRDist <= -1 || FRDist > 200);

    if (cantSeeLeft || cantSeeRight) {
        Serial.println("Cant read front sensor while aligning");

        navigator.turnRight();
        nextState_GP = followingLeftWall_S;
        return;
    }

    if (FLDist < FRDist) {
        drive.turnLeft();
    } else if (FLDist > FRDist) {
        drive.turnRight();
    } else {  // is aligned
        drive.stop();

        int frontDistance = ultrasonic.readFromRobotCenter();

        int leftDistance = leftInfrared.readFromRobotCenter();

        // Sets the current angle to the closest 90
        int wallsRecelebratedAgainst =
            motionTracker.recalibratePosition(frontDistance, leftDistance);

        if (wallsRecelebratedAgainst == 1) {
            // If against a wall, flash the Pixels red to indicate.
            pixels.setAll(255, 0, 0, true);
            delay(100);
        }
        if (wallsRecelebratedAgainst == 2) {
            pixels.setAll(255, 87, 51, true);
            // If in a corner, flash the Pixels pink to indicate.
            delay(100);
        }

        sendDataOverBLE();

        navigator.turnRight();
        nextState_GP = followingLeftWall_S;
        return;
    }
}

void UseMazeToGoTo(Position positionToGoTo) {
    drive.stop();
    pixels.setAll(255, 87, 51, true);

    gridMap.solve(brickList, positionToGoTo);

    nextState_GP = followingMaze_S;
}

void followingMaze_S() {
    static Angle angleToDrive = 90;

    Position robotPosition = motionTracker.getPosition();
    Angle robotAngle = motionTracker.getAngle();

    gridMap.getAngle(robotPosition, &angleToDrive);

    Angle angleToTurn = angleToDrive - robotAngle;

    drive.forwards(angleToTurn);

    int distanceToEndMM = gridMap.getEuclideanDistanceToEnd(robotPosition);

    const int range = 100;
    // if the robot is less than 100 mm from the goal, move onto the next
    // state.
    if (distanceToEndMM < range) {
        if (currentObjective_G == DriveToEndViaCentre) {
            nextState_GP = celebrating_S;
            currentObjective_G = CompletedMaze;
        } else if (currentObjective_G == DriveToStart) {
            currentObjective_G = DriveToEnd;
            UseMazeToGoTo({1300, 1800});
        } else if (currentObjective_G == DriveToEnd) {
            nextState_GP = celebrating_S;
            currentObjective_G = CompletedMaze;
        }
    }
}

void celebrating_S() {
    static int startedCelTime = millis();

    int celebratingDuration = millis() - startedCelTime;

    // First stop,
    if (celebratingDuration < 50) {
        drive.stop();

    }
    // Then rapidly spin for 2 seconds,
    else if (celebratingDuration < 2000) {
        drive.fullSpeedSpinLeft();
    }
    // Then stop again.
    else {
        drive.stop();
    }

    // Flash the LEDS
    int ledCount = pixels.getLedCount();
    pixels.clear();

    static bool ledToggle;
    PassiveSchedule ledToggleToggler(1000);

    // each second toggle which leds are on.
    if (ledToggleToggler.isReadyToRun()) {
        ledToggle = !ledToggle;
    }

    // Each second toggle alternating leds yellow
    for (int i = 0; i < (ledCount / 2); i++) {
        pixels.setPixel((i * 2) + ledToggle, 255, 255, 0);
    }
    pixels.show();
}

void colourCodeState(voidFuncPtr currentState_P) {
    if (currentState_P == followingLeftWall_S) {
        pixels.setAll(255, 255, 255);
    } else if (currentState_P == aligningWithWall_S) {
        pixels.setAll(0, 0, 255);
    } else if (currentState_P == followingMaze_S) {
        pixels.setAll(255, 0, 255);
    }
}

bool readyToGo = false;

void loop() {
    polls();

    static PassiveSchedule eachSecond(1000);

    byte bumperData = bumper.read();
    if (bumperData) {
        readyToGo = true;
        navigator.hitBumper(bumperData);

        Position robotPosition = motionTracker.getPosition();

        bool inFromLeft = (robotPosition.x > 300);
        bool inFromRight = (robotPosition.x < 1200);
        bool inFromBottom = (robotPosition.y > 600);
        bool inFromTop = (robotPosition.y < 1400);

        bool inMiddle =
            (inFromLeft && inFromRight && inFromBottom && inFromTop);

        // if the robot has hit a wall, while on the first attempt at driving
        // the maze, move to the next stage.
        if ((currentObjective_G == DriveToEndViaCentre) && (inMiddle)) {
            currentObjective_G = MapIsland;
            nextState_GP = followingLeftWall_S;
        }
    }

    if (readyToGo) {
        if (eachSecond.isReadyToRun()) {
            Position robotPosition = motionTracker.getPosition();
            gridMap.snowPlow(robotPosition);
        }

        colourCodeState(nextState_GP);
        if (!navigator.hasNoPath()) {
            pixels.setAll(0, 255, 0);
            navigator.moveToTarget();
        } else {
            nextState_GP();
        }
    } else {
        // Start if bluetooth is connected.
        readyToGo = bluetoothLowEnergy.isConnected();
    }

    // pixels.clear();
    pixels.show();

    if (Serial.available() > 0) {
        String data = Serial.readString();
        const int maxArgs_C = 10;
        String args[maxArgs_C];
        int foundArgs = 0;
        int spaceIndex = 0;

        while ((data.length() > 0) && (foundArgs < maxArgs_C) &&
               (spaceIndex != -1)) {
            spaceIndex = data.indexOf(" ");
            args[foundArgs] = data.substring(0, spaceIndex);
            data = data.substring(spaceIndex + 1);
            foundArgs++;
        }

        if (args[0] == "get-map") {
            drive.stop();

            gridMap.sendOverSerial();
        }
    }
}
